use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct AsbConfig {
    pub name: String,
    pub template: String,
    pub base_data_dir: String,
    pub bitcoin_network: String,
    pub monero_network: String,
    pub external_addresses: Vec<String>,
    pub enable_tor: bool,
    pub min_buy_btc: f64,
    pub max_buy_btc: f64,
    pub ask_spread: f64,
    pub price_ticker_url: String,
    pub developer_tip: f64,
    pub external_bitcoin_address: Option<String>,
}

impl Default for AsbConfig {
    fn default() -> Self {
        Self {
            name: String::new(),
            template: "mainnet".to_string(),
            base_data_dir: "/mnt/vault".to_string(),
            bitcoin_network: "Mainnet".to_string(),
            monero_network: "Mainnet".to_string(),
            external_addresses: vec![],
            enable_tor: true,
            min_buy_btc: 0.002,
            max_buy_btc: 0.02,
            ask_spread: 0.02,
            price_ticker_url: "wss://ws.kraken.com/".to_string(),
            developer_tip: 0.0,
            external_bitcoin_address: None,
        }
    }
}

impl AsbConfig {
    pub fn from_template(name: String, template: &str) -> Self {
        let mut config = match template {
            "mainnet" => Self::default(),
            "testnet" => Self {
                base_data_dir: "/mnt/vault-testnet".to_string(),
                bitcoin_network: "Testnet".to_string(),
                monero_network: "Stagenet".to_string(),
                enable_tor: false,
                min_buy_btc: 0.001,
                max_buy_btc: 0.1,
                ask_spread: 0.01,
                ..Default::default()
            },
            _ => Self::default(),
        };
        config.name = name;
        config.template = template.to_string();
        config
    }

    pub fn to_nix(&self) -> String {
        let external_addresses = if self.external_addresses.is_empty() {
            "        # \"/dns4/your-domain.com/tcp/9939\"\n        # \"/ip4/YOUR.PUBLIC.IP.ADDRESS/tcp/9939\""
                .to_string()
        } else {
            self.external_addresses
                .iter()
                .map(|addr| format!("        \"{}\"", addr))
                .collect::<Vec<_>>()
                .join("\n")
        };

        let external_btc_addr = if let Some(addr) = &self.external_bitcoin_address {
            format!("\n      externalBitcoinAddress = \"{}\";", addr)
        } else {
            "\n      # externalBitcoinAddress = \"bc1qyouraddresshere\";".to_string()
        };

        let components = format!(
            r#"
    # Enable individual components
    components = {{
      asb = true;        # Automated Swap Backend with Bitcoin/Monero nodes
      mempool = true;    # Mempool.space block explorer
      web = false;       # Eigenix web frontend (requires building)
      backend = false;   # Eigenix backend API (requires building)
    }};"#
        );

        format!(
            r#"# Eigenix Configuration: {}
# Generated by eigenix CLI from {} template
{{
  config,
  pkgs,
  ...
}}:
{{
  imports = [ ../nix/module.nix ];

  services.eigenix = {{
    enable = true;

    # Storage configuration
    baseDataDir = "{}";
{}

    # ASB Configuration
    asb = {{
      # External addresses for libp2p discovery
      externalAddresses = [
{}
      ];

      # Tor configuration
      enableTor = {};

      # Maker parameters
      minBuyBtc = {}; # Minimum {} BTC per swap
      maxBuyBtc = {}; # Maximum {} BTC per swap
      askSpread = {}; # {}% spread above market price
{}
    }};
  }};

  # Optional: Enable Tor system service for ASB hidden service
  # services.tor.enable = true;

  # Firewall is configured automatically for enabled services
}}
"#,
            self.name,
            self.template,
            self.base_data_dir,
            components,
            external_addresses,
            self.enable_tor,
            self.min_buy_btc,
            self.min_buy_btc,
            self.max_buy_btc,
            self.max_buy_btc,
            self.ask_spread,
            self.ask_spread * 100.0,
            external_btc_addr
        )
    }

    pub fn save(&self, base_path: &Path) -> Result<PathBuf> {
        let instances_dir = base_path.join("nix").join("instances");
        fs::create_dir_all(&instances_dir).context("Failed to create instances directory")?;

        let config_path = instances_dir.join(format!("{}.nix", self.name));
        let nix_content = self.to_nix();

        fs::write(&config_path, nix_content).context("Failed to write configuration file")?;

        Ok(config_path)
    }
}

pub fn get_project_root() -> Result<PathBuf> {
    // Start from current directory and walk up to find the project root
    let mut current = std::env::current_dir()?;

    loop {
        // Check if we're in the eigenix project root
        if current.join("nix").exists() && current.join("flake.nix").exists() {
            return Ok(current);
        }

        // Try parent directory
        if let Some(parent) = current.parent() {
            current = parent.to_path_buf();
        } else {
            anyhow::bail!("Could not find eigenix project root. Make sure you're running this command from within the eigenix project directory.");
        }
    }
}

pub fn list_configs(base_path: &Path) -> Result<Vec<String>> {
    let instances_dir = base_path.join("nix").join("instances");

    if !instances_dir.exists() {
        return Ok(vec![]);
    }

    let mut configs = vec![];
    for entry in fs::read_dir(instances_dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.extension().and_then(|s| s.to_str()) == Some("nix") {
            if let Some(name) = path.file_stem().and_then(|s| s.to_str()) {
                configs.push(name.to_string());
            }
        }
    }

    configs.sort();
    Ok(configs)
}

pub fn get_config_path(base_path: &Path, name: &str) -> PathBuf {
    base_path
        .join("nix")
        .join("instances")
        .join(format!("{}.nix", name))
}

pub fn config_exists(base_path: &Path, name: &str) -> bool {
    get_config_path(base_path, name).exists()
}
